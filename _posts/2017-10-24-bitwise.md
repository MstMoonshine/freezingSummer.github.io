---
layout: post
title: 位运算简介
tags: Algorithms

---
数据在计算机中以二进制的形式储存，于是关于二进制的运算演化出了一套数学体系--布尔代数（Bool algebra）。布尔代数起源于George Boole，他在1850年前后提出，逻辑值“真”和“假”可以与1和0相对应，这成为布尔代数的基础。

## 逻辑运算与布尔运算
### 首先探讨对单个布尔变量的运算。

常见的逻辑运算有四种：
- 与（AND）：逻辑运算\\(\land\\)对应布尔运算&
- 或（OR）：逻辑运算\\(\lor\\)对应布尔运算\\(\lvert\\)
- 非（NOT）：逻辑运算\\(\lnot\\)对应布尔运算~
- 异或（XOR）：逻辑运算\\(\bigoplus\\)对应布尔运算^

前三种无须过多说明，第四种不易从字面上理解，却能演化出很多神奇的结果，下面给出异或运算的真假值表：

^ | 0 | 1
- | - | -
0 | 0 | 1
1 | 1 | 0

用语言表述\\(\bigoplus\\)的运算法则即“同假异真”。

---

### 对多个布尔变量的批量运算

在对一组变量同时进行同一种运算时，为了方便表示，我们引入了**向量**的概念，类似地，在对多个布尔变量进行同一种运算时，我们引入**位向量**的概念。

简单来说，位向量就是一组0和1串在一起，比如[10110]或者[00010]**（先不要把位向量看成普遍理解的二进制数字，后面会介绍到位向量对应实数有多种不同的对应方式，暂时就将它们看成相互的独立的一串数字）**

引入位向量概念后就可以将上述四种布尔运算推广到位运算之间的运算：分别对对应位置的布尔变量进行运算即可。

#### 位向量的简单应用

在有限集U确定的情况下，位向量可以表示U的子集A：

以U = {0, 1, 2, ..., n - 1}为例， 我们用位向量
\\[[a_{n-1}, a_n, ..., a_2, a_1]\\]
表示A，其中\\(a_i=1\\)当且仅当\\(i\in A\\)。

如n = 8时，位向量**a**=[01101001]表示A = {0, 3, 5, 6}，位向量**b**=[01010101]表示B = {0, 2, 4, 6}。

位向量提供的便利在于可以通过对**a**、**b**间的布尔运算完成A、B之间的集合运算，如:

a & b = [01000001] 代表 \\(A \cup B=\\){0, 6}
a | b = [01111101] 代表 \\(A \cap B=\\){0, 2, 3, 4, 5, 6}
~a = [10010110] 代表 U中A的补集\\(\bar{A}=\\){1, 2, 4, 7}

## 布尔运算的实际操作

### 1.异或运算与变量交换
通常在学习交换两个变量数值这样的基础算法时，老师总是会提到一个关于杯子的经典例子，来告诉我们交换两个变量貌似必须引入第三个变量：

假设有两个杯子，一杯装了蓝墨水，一杯装了红墨水，现在要求交换两个杯子中的墨水。

按照正常思路，我们必须拿出第三个杯子，来暂时储存一个杯子中的墨水，才能完成交换，代码实现如下：

``` c
void swap(int &x, int &y) {
    int tmp = x;
    x = y;
    y = tmp;
}
```

但是其实我们还有一种**不需要第三个杯子**的方法来完成：将蓝墨水倒入红墨水中，在倒回的过程中，利用某种机制，使得蓝墨水无法倒出，而红墨水自动倒出。

上述过程由于热力学定律的限制，很难真正实现，但在计算机中确实可以完成的--利用异或运算。

首先我们先从异或运算的性质开始分析：

根据异或运算的定义，显然有：
 1. 单位元0：\\(a^{\hat{}}a=0\\)
 2. 逆元为其自身：\\(a^{\hat{}}0=a\\)
 3. 交换律：\\(a^{\hat{}}b=b^{\hat{}}a\\)
 4. 结合律（尽管没那么显然）：\\(a^{\hat{}}(b^{\hat{}}c)=(a^{\hat{}}b)^{\hat{}}c\\)

于是有：
\\[a^{\hat{}}(b^{\hat{}}a)=a^{\hat{}}(a^{\hat{}}b)=(a^{\hat{}}a)^{\hat{}}b=0^{\hat{}}b=b\\]
上式将是我们交换变量的理论基础。

现在先给出代码，再加以解释：
``` c
void swap_xor(int &x, int &y) {
    x ^= y; //等价于x = x ^ y;
    y ^= x;
    x ^= y;
}
```
这三行完全没有直观性可言的命令便完成了x和y的交换，下面我们从计算机的视角来跟踪一下具体发生了什么：（注意虽然异或是对位向量完成的运算，但是由于数据以二进制形式储存，所以异或可以对int整型变量操作）

让我们把x的初始值记为a，y的初始值记为b来模拟上述过程则：

 1. x = a ^ b（将a和b揉在一起）
 2. y = b ^ (a ^ b) = a（用b将自身抵消，取出a）
 3. x = (a ^ b) ^ a = b（用a将自身抵消，取出b）

于是结果为x = b, y = a完成了交换。

这是一个很tricky的做法，但是并不常用。因为这种算法并不能降低时间复杂度，而空间上也仅仅是减少了一个变量的损失，加之不够直观，所以在应用层上的代码很少这么写，只是当成一个思维游戏。但对于系统最底层的算法，或一些内存很小的单片机来说，这样的算法就能用得到了。

### 2.与、或\\(\rightarrow\\)变量截取与清除
相对于上述变量交换的算法，这里介绍的算法看上去没那么“神奇”，但是更加常用。

对一个位向量，假如要获取其中某一段特定的数据，只需要和一段掩码进行&运算即可。掩码中，需要的数据对应的位全部设置为1，其余为0即可。如需要获取\\(x = [1001011010]\\)中的后五位数，只需要取\\(a = [0000011111]\\)，则：
\\[x\&a=[0000011010]\\]
x & a会将掩码中所有的0位擦除，所有的1位保留

类似地，用x \\(\lvert\\) a运算，则：
\\[x\lvert a=[1001011111]\\]
会将所有掩码中的0位保留，1位擦除为1。但我们更倾向于将不用的数据设为0，所以用&运算的截取与清除比|运算更常用。

**注意：**若需要一段全为0的掩码，只需要取a = 0，但是如果需要取一段全为1的掩码，我们并不知道需要的掩码有多长，在32位和64位机器上，有的数据类型的字节数并不相同（如long long int），这时只需要取a = ~0即可。

## 位向量与数的对应方式

位向量一共有四种标准方式去对应一个数，分别是无符号编码、补码、反码和原码，这里主要介绍更为常用的前两种方式，且暂时不讨论浮点数，以整数为例。

### 无符号编码
无符号编码就是最普遍意义的二进制数了，根据此前的文章[《大数计算——高精度算法》](http://freezingsummer.com/2017/10/big-integer-calculation/)所介绍，二进制数从右向左数第 \\(i\\) 位的权值为\\(2^{i-1}\\)，只需要将各位上的数值乘以权值求和，即可得到对应的十进制数字了。对一个长度为 w 位向量，数学上用Binary to Unsigned函数\\(B2U_w(x)\\)表示其值：
\\[B2U_w(x)=\sum_{i=0}^{w-1}x_i2^i\\]
其中**x**是位向量，函数取值为此位向量对应的数。

### 补码编码
在更多情况下我们希望使用的是有符合数，于是产生了计算机中最常见的位向量与数值对应的方式--补码编码：将最高位权值加上一个负号（此处最高位指的不是第 w 位，而是左起第一个不为 0 的位）。

补码编码数学上用Binary to Two's-complement函数\\(B2T_w(x)\\)表示：
\\[B2T_w(x)=-x_{w-1}2^{w-1}+\sum_{i=0}^{w-2}x_i2^i\\]
其中**x**为位向量，函数值为其对应的有符号数。

数学公式太过抽象，下面举例说明：

\\(B2T_w([0001])=-0\cdot2^3+0\cdot2^2+0\cdot2^1+1\cdot2^0=0+0+0+1=1\\)

\\(B2T_w([1111])=-1\cdot2^3+1\cdot2^2+1\cdot2^1+1\cdot2^0=-8+4+2+1=-1\\)

\\(B2T_w([0101])=-0\cdot2^3+1\cdot2^2+0\cdot2^1+1\cdot2^0=0+4+0+1=5\\)

\\(B2T_w([1011])=-1\cdot2^3+0\cdot2^2+1\cdot2^1+1\cdot2^0=-8+0+2+1=-5\\)

由于最高位权值很大，即使剩下所有位全都是1，其值还是会比最高位小1(\\(2^n=\sum_{i=0}^{n-1}2^i+1\\))，所以最高位是0则此数字为正，最高位为1则此数字为负。即最高位是0或1，决定了位向量代表的数是正还是负。

在位向量位数相同的情况下，可以看出两种表示方法的取值范围之间的关系：

\\(B2U_w(x)_{min}=B2U_w([00...0])=0\\)

\\(B2U_w(x)_{max}=B2U_w([11...1])=2^w-1\\)

\\(B2T_w(x)_{min}=B2T_w([10...0])=-2^{w-1}\\)

\\(B2T_w(x)_{max}=B2T_w([01...1])=2^{w-1}-1\\)

这就解释了为何int型变量的取值范围为-2 147 483 648 ～ 2 147 483 647（\\(-2^{31}\rightarrow2^{31}-1\\)），而unsigned int型变量的取值范围为0 ~ 4 294 967 295(\\(2^{32}-1\\))

## 移位运算
C语言中提供了一种移位运算，分为左移（\\(< <\\)）和右移（\\(> >\\)）。

左移 k 位即 \\(x< <k\\) ，会在位向量**x**后加 k 个 0，并舍去前 k 个数以保证长度不变。

右移 k 位即 \\(x> >k\\)，但右移分为算数右移和逻辑右移两种：

 - 算数右移：位向量后 k 位丢弃并在最高位加 k 个 0
 - 逻辑右移：位向量后 k 位丢弃并在最高位加 k 个与最高位相同的数，最高位为 1 则添加 1，为 0 则添加 0
 
为何要有如此古怪的设定？这是因为移位运算与乘除法直接的关系：

### 左移与乘法
若让计算机计算\\(8x\\)的值，最简单的想法便是进行7次相加，但是这样的操作效率太低，只需要将 x 左移 3 位，即\\(x< <3\\)，即可。

也就是说左移 k 位，相当于乘以\\(2^k\\)。

若要计算\\(nx\\)的值，其中n不为2的次方数，可以将n表示为若干个2的次方数求和（类似于转化为二进制的写法），分别移位后再求和，如：
\\[5x=(x< <2)+x\\]
\\[15x=(x< <3)+(x< <2)+(x< <1)+x\\]
C语言中上式的括号是必须的，因为加法的运算优先度大于移位运算。

这样将\\(5x\\)的4次加法变成了一次移位和一次加法，\\(15x\\)的14次加法变成了3次移位和3次加法，从而实现了算法优化。

### 右移与整除
对于正整数而言，和左移类似，右移代表了除法，但若被除数不是2的次方数，即没办法被\\(2^k\\)整除，则会**向下取整**，即整除运算，这是因为移位时舍去了后k位。

那么为何需要分逻辑右移和算数右移呢？

这源于符号。根据上面所说，无符号数采用无符号编码，而有符号数采用补码编码。补码编码中最高位代表了数的符号，若一律采用逻辑右移，则无法保证移位前后符号不变，且无法保证依然具有整除的意义。而算数右移保证了这一点，如：

```101001```用补码编码代表-23，对其向右移 2 位，算数右移的结果是```111010```，代表-6，这是-23整除4的结果（在正整数情况下整除运算即保留整数部分，而舍去小数部分；但在负整数情况下，向下取整则会把整数部分的绝对值加 1并舍去小数部分），而逻辑右移的结果是```001010```，代表10，并无明显的数学意义。

因此，在C语言中，对无符号数采用逻辑右移，而对有符号数采用算数右移。

此外，若除数不为\\(2^k\\)形式，则无法向乘法那样分别右移处理，因为显然\\(7x=4x+2x+x\\)，但是\\(\frac{x}{7}\ne\frac{x}{4}+\frac{x}{2}+x\\)

# EOF
既然位运算能够优化乘法，那么这种类似的方法是否可以高精度乘法呢？假如用在高精度中，那么每一位数就要用队列来作为数据结构储存了，而不能再用vector或者数组，否则无法快速进行移位操作。以后有时间再来探讨这些问题，下一篇博客可能是关于物理或者数学的了，毕竟有一段时间没有深入研究物理数学了。

//本文中部分例子来自《深入理解计算机系统》